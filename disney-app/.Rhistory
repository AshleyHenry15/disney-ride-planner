}
# generates options CPP code in boost::program_options format
generateProgramOptions <- function (optionsJson, overlayOptionsJson) {
metadata <- optionsJson$metadata
outputSourceFile <- metadata$outputSourceFile
if (is.null(outputSourceFile)) {
stop("Required metadata parameter outputSourceFile not specified")
}
# generate copyright notice
sourceFilename <- basename(outputSourceFile)
generatedContents <- generateCopyright(sourceFilename)
# generate hand edit warning
generatedContents <- paste(generatedContents, generateHandEditWarning(), sep="\n\n")
# generate include guard
includeGuard <- getIncludeGuard(metadata)
generatedContents <- paste(generatedContents, generateIncludeGuard(includeGuard), sep="\n\n")
# generate include directives
includes <- c("<string>", "<map>", "<shared_core/FilePath.hpp>", "<core/ProgramOptions.hpp>")
additionalIncludes <- metadata$additionalIncludes
includes <- c(includes, additionalIncludes)
generatedContents <- paste(generatedContents, generateIncludes(includes), sep="\n\n")
# generate namespace
namespace <- metadata$namespace
generatedContents <- paste(generatedContents, generateNamespace(namespace), sep="\n\n")
# generate class which holds the options
classContents <- paste0("class GeneratedOptions\n",
"{\n",
"public:\n",
"   virtual ~GeneratedOptions() {}\n",
"   virtual core::ProgramStatus read(int argc,\n",
"                                    char * const argv[],\n",
"                                    std::ostream& osWarnings) = 0;")
# generate accessors and members
accessors <- "public:\n"
members <- "protected:\n"
options <- optionsJson$options
for (category in names(options)) {
for (option in options[[category]]) {
# build property for this option
name <- option$name
type <- cppTypeFromJsonType(option$type)
if (is.null(type)) {
stop(sprintf("No type specified for option %s", name))
}
# fix up member type for commonly used non-boost types
memberType <- type
if (identical(memberType, "core::FilePath")) {
memberType <- "std::string"
}
memberName <- option$memberName
if (!is.null(memberName)) {
members <- paste0(members, sprintf("   %s %s;\n", memberType, memberName))
}
# build accessor for this option
skipAccessor <- option$skipAccessorGeneration
if (is.null(skipAccessor)) {
skipAccessor <- FALSE
}
if (skipAccessor) {
next
}
accessorName <- option$accessorName
if (is.null(accessorName)) {
if (!is.null(memberName)) {
# default accessor to the member name without any trailing underscores
accessorName <- str_replace(memberName, fixed("_"), "")
} else {
stop(sprintf("One of accessorName or memberName must be specified for option %s", name))
}
}
accessorCode <- ""
accessorValue <- option$accessorValue
if (is.null(accessorValue)) {
# handle any implicit conversions that we should support
if (identical(type, "core::FilePath")) {
accessorCode <- sprintf("return core::FilePath(%s);", memberName)
} else if (identical(category, "allow")) {
accessorCode <- sprintf("return %s || allowOverlay();", memberName)
} else {
accessorCode <- sprintf("return %s;", memberName)
}
} else {
accessorCode <- accessorValue[["code"]]
if (is.null(accessorCode)) {
stop(sprintf("Invalid accessorValue specified - must be a code specification: %s", accessorValue))
}
}
accessors <- paste0(accessors, sprintf("   %s %s() const { %s }\n", type, accessorName, accessorCode))
}
}
# generate the buildOptions function which handles the boost options interface
buildOptions <- paste0("protected:\n",
"   rstudio::core::program_options::OptionsDescription\n",
"   buildOptions(")
buildOptionsArgs <- c()
categoryVars <- c()
for (category in names(options)) {
# transform category names into output parameters
categoryParam <- category
substr(categoryParam, 1, 1) <- toupper(substr(categoryParam, 1, 1))
categoryParam <- paste0("p", categoryParam)
categoryVars[category] <- categoryParam
buildOptionsArgs <- append(buildOptionsArgs, sprintf("boost::program_options::options_description* %s", categoryParam))
}
for (category in names(options)) {
for (option in options[[category]]) {
tempName <- option$tempName
tempType <- cppTypeFromJsonType(option$tempType)
if (!is.null(tempName) && !is.null(tempType)) {
buildOptionsArgs <- append(buildOptionsArgs, sprintf("%s* %s", tempType, tempName))
}
}
}
buildOptionsArgsStr <- paste(buildOptionsArgs, collapse=",\n                ")
buildOptions <- paste0(buildOptions,
buildOptionsArgsStr,
")\n{\n",
"   using namespace rstudio::core;\n",
"   using namespace boost::program_options;\n")
# now generate the meat of the function, the boost program options integration
boostOptions <- c()
for (category in names(options)) {
if (length(boostOptions) > 0) {
# stamp the ending semicolon for the last option in the previous category
boostOptions <- paste0(boostOptions, ";")
}
boostOptions <- paste(boostOptions, sprintf("%s->add_options()", categoryVars[[category]]), sep="\n\n   ")
for (option in options[[category]]) {
optionName <- option$name
if (is.null(optionName)) {
# no member name means this is likely just an accessor option and should not be a true option
# simply continue to the next
next
}
# fixup constants for names
isOptionNameConstant <- FALSE
if (identical(typeof(optionName), "list")) {
optionName <- optionName[["constant"]]
isOptionNameConstant <- TRUE
}
isShortNameConstant <- FALSE
shortName <- option$shortName
if (identical(typeof(shortName), "list")) {
shortName <- shortName[["constant"]]
isShortNameConstant <- TRUE
}
storageType <- cppTypeFromJsonType(option$tempType)
if (is.null(storageType)) {
storageType <- cppTypeFromJsonType(option$type)
if (is.null(storageType)) {
stop(sprintf("No variable type defined for option %s", optionName))
}
}
# last minute type fixes for commonly used non-boost types
if (identical(storageType, "core::FilePath")) {
storageType <- "std::string"
}
storageMember <- option$tempName
if (is.null(storageMember)) {
# if no temp variable was defined, then use the member variable
storageMember <- paste0("&", option$memberName)
if (is.null(storageMember)) {
stop(sprintf("No memberName or tempName defined for option %s", optionName))
}
}
# fix up the default value based on the variable type
defaultValue <- option$defaultValue
if (is.null(defaultValue)) {
# resolve the default value based on the variable type
if (identical(storageType, "std::string")) {
defaultValue <- "std::string()"
} else if (identical(storageType, "bool")) {
defaultValue <- "true"
} else if (identical(storageType, "std::vector<std::string>")) {
defaultValue <- "std::vector<std::string>()"
} else {
stop(sprintf("No defaultValue specified for option %s, and could not be inferred", optionName))
}
} else {
defaultValueCode <- if (identical(typeof(defaultValue), "list")) defaultValue[["code"]] else NULL
if (is.null(defaultValueCode)) {
if (identical(storageType, "std::string")) {
if (defaultValue != "std::string()") {
# strings need to be quoted
defaultValue <- sprintf("\"%s\"", defaultValue)
}
} else if (identical(storageType, "bool")) {
defaultValue <- if (defaultValue) "true" else "false"
}
} else {
defaultValue <- defaultValueCode
}
}
implicitValueStr <- ""
implicitValue <- option$implicitValue
if (is.null(implicitValue)) {
implicitValueStr <- ""
} else {
implicitValueCode <- if (identical(typeof(implicitValue), "list")) implicitValue[["code"]] else NULL
if (is.null(implicitValueCode)) {
if (identical(storageType, "std::string")) {
if (implicitValue != "std::string()") {
# strings need to be quoted
implicitValue <- sprintf("\"%s\"", implicitValue)
}
} else if (identical(storageType, "bool")) {
implicitValue <- if (implicitValue) "true" else "false"
}
} else {
implicitValue <- defaultValueCode
}
implicitValueStr <- sprintf("->implicit_value(%s)", implicitValue)
}
isMultitoken <- option$isMultitoken
if (is.null(isMultitoken)) {
isMultitoken <- FALSE
}
multitoken <- ""
if (isMultitoken) {
multitoken <- "->multitoken()"
}
description <- option$description
if (is.null(description)) {
stop(sprintf("No description specified for option %s", optionName))
}
description <- str_replace_all(description, fixed("\""), "\\\"")
description <- sprintf("\"%s\"", description)
optionName <- if (isOptionNameConstant) optionName else sprintf("\"%s\"", optionName)
if (!is.null(shortName)) {
shortName <- if (isShortNameConstant) shortName else sprintf("\"%s\"", shortName)
shortName <- sprintf("%s", shortName)
optionName <- sprintf("%s \",\" %s", optionName, shortName)
}
optionSet <- paste0(sprintf("      (%s,\n", optionName),
sprintf("      value<%s>(%s)->default_value(%s)%s%s,\n", storageType, storageMember, defaultValue, implicitValueStr, multitoken),
sprintf("      %s)", description))
boostOptions <- paste(boostOptions, optionSet, sep="\n")
}
}
boostOptions <- trimws(boostOptions, "left")
boostOptions <- paste0(boostOptions, ";")
buildOptions <- paste(buildOptions, boostOptions, sep="\n   ")
# generate config file information
configFile <- metadata$configFile
binary <- str_replace(configFile, fixed(".conf"), "")
buildOptions <- paste0(buildOptions,
"\n\n",
sprintf("   FilePath defaultConfigPath = core::system::xdg::findSystemConfigFile(\"%s configuration\", \"%s\");\n", binary, configFile),
"   std::string configFile = defaultConfigPath.exists() ?\n",
"      defaultConfigPath.getAbsolutePath() : \"\";\n",
sprintf("   return program_options::OptionsDescription(\"%s\", configFile);", binary))
# close out the buildOptions function
buildOptions <- paste0(buildOptions, "\n}")
classContents <- paste(classContents, buildOptions, sep="\n\n")
classContents <- paste(classContents, accessors, sep="\n\n")
classContents <- paste(classContents, members, sep="\n\n")
classContents <- paste(classContents, "  virtual bool allowOverlay() const { return false; };\n")
# finally, close out the class
classContents <- paste0(classContents, "};")
classContents <- paste(classContents, generateEndNamespace(namespace), sep="\n\n")
classContents <- paste(classContents, generateEndIncludeGuard(includeGuard), sep="\n\n")
generatedContents <- paste(generatedContents, classContents, sep="\n")
writeLines(generatedContents, con = outputSourceFile)
# generate overlay options if applicable
if (!is.null(overlayOptionsJson)) {
generateOverlayOptions(overlayOptionsJson)
}
}
generateOverlayOptions <- function (overlayOptionsJson) {
metadata <- overlayOptionsJson$metadata
if (is.null(metadata)) {
stop("Overlay options missing required metadata parameter")
}
outputSourceFile <- metadata$outputSourceFile
if (is.null(outputSourceFile)) {
stop("Overlay options missing required metadata parameter outputSourceFile")
}
outputHeaderFile <- metadata$outputHeaderFile
if (is.null(outputHeaderFile)) {
stop("Overlay options missing required metadata parameter outputHeaderFile")
}
# generate copyright notice
sourceFilename <- basename(outputSourceFile)
headerFilename <- basename(outputHeaderFile)
generatedHeaderContents <- generateCopyright(headerFilename)
generatedSourceContents <- generateCopyright(sourceFilename)
# generate hand edit warning
warning <- generateHandEditWarning()
generatedSourceContents <- paste(generatedSourceContents, warning, sep="\n\n")
generatedHeaderContents <- paste(generatedHeaderContents, warning, sep="\n\n")
# generate include of header file in cpp file
pos <- str_locate(outputHeaderFile, "include/")[2]
if (!is.na(pos)) {
includeDirective <- sprintf("#include <%s>", substr(outputHeaderFile, pos + 1, str_length(outputHeaderFile)))
}
generatedSourceContents <- paste(generatedSourceContents, includeDirective, sep="\n\n")
# generate include guard
includeGuard <- getIncludeGuard(metadata)
generatedHeaderContents <- paste(generatedHeaderContents, generateIncludeGuard(includeGuard), sep="\n\n")
# generate include directives
includes <- c("<string>", "<map>", "<shared_core/FilePath.hpp>", "<core/ProgramOptions.hpp>")
additionalIncludes <- metadata$additionalIncludes
if (!is.null(additionalIncludes)) {
includes <- c(includes, additionalIncludes)
}
generatedHeaderContents <- paste(generatedHeaderContents, generateIncludes(includes), sep="\n\n")
# generate #define directives for all of the specified overlay options constants
options <- overlayOptionsJson$options
constants <- data.frame(Constant=character(), Value=character())
for (category in names(options)) {
for (option in options[[category]]) {
optionName <- option$name
if (is.null(optionName)) {
stop("Option with no name specified in overlay options. All overlay options must specify a name.")
}
optionConstant <- optionName[["constant"]]
if (is.null(optionConstant)) {
stop(sprintf("Overlay option %s specified without a constant. All overlay option names must be constants.", optionName))
}
optionConstantValue <- optionName[["value"]]
if (is.null(optionConstantValue)) {
stop(sprintf("Overlay option %s constant specified without a value. All constants must have values for documentation.", optionName))
}
skipDefine <- optionName[["skipDefine"]]
if (!is.null(skipDefine) && skipDefine) {
# this definition should be skipped - it is most likely an external definition
next
}
constants <- constants %>% add_row(Constant = optionConstant, Value = optionConstantValue)
}
}
# add additional constants
additionalConstants <- metadata$additionalConstants
if (!is.null(additionalConstants)) {
for (constant in additionalConstants) {
constants <- constants %>% add_row(Constant = constant[["constant"]], Value = constant[["value"]])
}
}
defines <- ""
nameLengths <- c()
for (i in seq_len(nrow(constants))) {
constant <- constants[i,]
# ensure the constant values line up properly by tracking how many spaces they should have after the constant
optionConstant <- constant[["Constant"]]
optionConstantValue <- constant[["Value"]]
constantLength <- str_length(optionConstant)
nameLengths <- append(nameLengths, constantLength)
defines <- paste0(defines, "#define ", optionConstant, sprintf("<SPACER%s>", i), sprintf("\"%s\"", optionConstantValue), "\n")
}
# fill in spacers to line up the constants to make them more readable
iter <- 1
maxNameLengths <- max(unlist(nameLengths))
for (i in nameLengths) {
spaces <- strrep(" ", maxNameLengths - i + 1)
defines <- str_replace_all(defines, fixed(sprintf("<SPACER%s>", iter)), spaces)
iter <- iter+1
}
generatedHeaderContents <- paste(generatedHeaderContents, defines, sep="\n\n")
# generate namespace
namespace <- metadata$namespace
generatedSourceContents <- paste(generatedSourceContents, generateNamespace(namespace), sep="\n\n")
# generate addOverlayOptions function
addOverlayOptionsFunc <- paste0("void Options::addOverlayOptions(\n      ")
categoryVars <- c()
overlayOptionsArgs <- c()
for (category in names(options)) {
# transform category names into output parameters
categoryParam <- category
substr(categoryParam, 1, 1) <- toupper(substr(categoryParam, 1, 1))
categoryParam <- paste0("p", categoryParam)
categoryVars[category] <- categoryParam
overlayOptionsArgs <- append(overlayOptionsArgs, sprintf("boost::program_options::options_description* %s", categoryParam))
}
overlayOptionsArgsStr <- paste(overlayOptionsArgs, collapse = ",\n      ")
addOverlayOptionsFunc <- paste0(addOverlayOptionsFunc, overlayOptionsArgsStr, ")\n{\n",
"   using namespace boost::program_options;\n")
# now generate the meat of the function, the boost program options integration
boostOptions <- c()
for (category in names(options)) {
if (length(boostOptions) > 0) {
# stamp the ending semicolon for the last option in the previous category
boostOptions <- paste0(boostOptions, ";")
}
boostOptions <- paste(boostOptions, sprintf("%s->add_options()", categoryVars[[category]]), sep="\n\n   ")
for (option in options[[category]]) {
optionName <- option$name
optionName <- optionName[["constant"]]
type <- option$type
defaultValue <- option$defaultValue
if (is.null(defaultValue)) {
defaultValue <- "std::string()"
} else {
defaultValueCode <- if (identical(typeof(defaultValue), "list")) defaultValue[["code"]] else NULL
if (is.null(defaultValueCode)) {
if (defaultValue != "std::string()") {
if (identical(type, "bool")) {
# convert TRUE and FALSE to "1" and "0"
if (identical(typeof(defaultValue), "logical")) {
defaultValue <- if (defaultValue) "1" else "0"
}
}
# strings need to be quoted
defaultValue <- sprintf("\"%s\"", defaultValue)
}
} else {
defaultValue <- defaultValueCode
}
}
description <- option$description
if (is.null(description)) {
stop(sprintf("No description specified for option %s", optionName))
}
description <- str_replace_all(description, fixed("\""), "\\\"")
description <- sprintf("\"%s\"", description)
optionSet <- paste0(sprintf("      (%s,\n", optionName),
sprintf("      value<std::string>(&overlayOptions_[%s])->default_value(%s),\n", optionName, defaultValue),
sprintf("      %s)", description))
boostOptions <- paste(boostOptions, optionSet, sep="\n")
}
}
boostOptions <- trimws(boostOptions, "left")
boostOptions <- paste0(boostOptions, ";")
addOverlayOptionsFunc <- paste(addOverlayOptionsFunc, boostOptions, sep="\n   ")
generatedSourceContents <- paste(generatedSourceContents, addOverlayOptionsFunc, sep="\n")
# close out the function
generatedSourceContents <- paste(generatedSourceContents, "}", sep="\n")
generatedSourceContents <- paste(generatedSourceContents, generateEndNamespace(namespace), sep="\n\n")
generatedHeaderContents <- paste(generatedHeaderContents, generateEndIncludeGuard(includeGuard), sep="\n\n")
writeLines(generatedSourceContents, con = outputSourceFile)
writeLines(generatedHeaderContents, con = outputHeaderFile)
}
# generates options CPP code and admin guide documentation for the given options JSON file
generate <- function (optionsFile) {
optionsJson <- jsonlite::read_json(optionsFile)
metadata <- optionsJson$metadata
if (is.null(metadata)) {
stop(sprintf("Options file %s missing required metadata section", optionsFile))
}
generatorType <- metadata$generatorType
if (is.null(generatorType)) {
generatorType <- "ProgramOptions"
}
if (identical(generatorType, "ProgramOptions")) {
directory <- dirname(optionsFile)
filename <- tools::file_path_sans_ext(basename(optionsFile))
ext <- tools::file_ext(optionsFile)
overlayFile = file.path(directory, sprintf("%s-overlay.%s", filename, ext))
overlayOptionsJson <- NULL
if (file.exists(overlayFile)) {
overlayOptionsJson <- jsonlite::read_json(overlayFile)
}
cat(sprintf("Generating program options from %s\n", optionsFile))
if (!is.null(overlayOptionsJson)) {
cat(sprintf("Using overlay options file %s\n", overlayFile))
}
generateProgramOptions(optionsJson, overlayOptionsJson)
cat("Generating documentation\n")
generateQmd(optionsJson, overlayOptionsJson)
} else {
stop(sprintf("Requested generator type %s is not supported", generatorType))
}
}
main <- function () {
args <- commandArgs(trailingOnly=TRUE)
if (length(args) == 0) {
args <- defaultOptionsFiles
}
for (optionsFile in args) {
if (!file.exists(optionsFile)) {
stop(sprintf("Options file %s does not exist - ensure your working directory is set to this script's location",
optionsFile))
}
generate(optionsFile)
}
cat("Options generated successfully, verifying resulting options...\n")
cat("Press [enter] to continue or CTRL+C to skip")
a <- readLines("stdin",n=1);
system("bash report-options.sh")
}
main()
shiny::runApp('~/GitHub/Repositories/disney-app/disney-app')
install.packages(DT)
install.packages(library(DT)0
install.packages(library(DT))
install.packages(library(DT))
install.packages(library(DT))
install.packages(library(DT))
install.packages(library(DT))
install.packages("DT")
shiny::runApp('~/GitHub/Repositories/disney-app/disney-app')
runApp()
runApp('~/GitHub/Repositories/disney-app/disney-app')
runApp('~/GitHub/Repositories/disney-app/disney-app')
runApp('~/GitHub/Repositories/disney-app/disney-app')
runApp('~/GitHub/Repositories/disney-app/disney-app')
library(readr)
disney_ride_data <- read_csv("~/GitHub/Repositories/disney-app/disney-app/disney-ride-data.csv",
col_types = cols(height_requirement = col_number(),
avg_wait_time = col_number()))
View(disney_ride_data)
runApp('~/GitHub/Repositories/disney-app/disney-app')
library(readr)
disney_ride_data <- read_csv("~/GitHub/Repositories/disney-app/disney-app/disney-ride-data.csv")
View(disney_ride_data)
runApp('~/GitHub/Repositories/disney-app/disney-app')
library(readr)
disney_ride_data <- read_csv("~/GitHub/Repositories/disney-app/disney-app/disney-ride-data.csv")
View(disney_ride_data)
runApp('~/GitHub/Repositories/disney-app/disney-app')
runApp('~/GitHub/Repositories/disney-app/disney-app')
runApp('~/GitHub/Repositories/disney-app/disney-app')
runApp('~/GitHub/Repositories/disney-app/disney-app')
